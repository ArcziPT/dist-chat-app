{"version":3,"sources":["app/hooks.ts","features/messages/messagesSlice.ts","features/messages/messagesAPI.ts","features/session/sessionAPI.ts","features/session/sessionSlice.ts","components/Chat.tsx","components/Login.tsx","components/Home.tsx","App.tsx","app/store.ts","serviceWorker.ts","index.tsx"],"names":["useAppDispatch","useDispatch","useAppSelector","useSelector","getMessagesAsync","createAsyncThunk","msgRequest","a","channelId","timestamp","amount","axios","get","response","data","messagesSlice","createSlice","name","initialState","reducers","addMessage","state","action","hasOwnProperty","payload","push","msg","extraReducers","builder","addCase","fulfilled","length","toString","concat","sort","m1","m2","actions","login","loginRequest","post","status","token","user","servers","connection","loginAsync","headers","getChannelsAsync","sessionSlice","logoutAction","pending","username","id","userId","Chat","sessionStatus","session","history","useHistory","dispatch","useState","selectedServer","setSelectedServer","selectedChannel","setSelectedChannel","input","setInput","msgs","messages","href","window","location","socketUrl","substring","useWebSocket","sendMessage","lastMessage","readyState","useEffect","serverId","JSON","stringify","type","ReadyState","OPEN","parse","console","log","channels","Date","now","selectedServerChannels","selectedChannelMsgs","selectServer","idx","findIndex","server","selectChannel","channel","formatTimestamp","date","hours","getHours","minutes","getMinutes","seconds","getSeconds","year","getFullYear","month","getMonth","getDay","substr","selectedServerId","selectedChannelId","className","map","onClick","text","onChange","event","preventDefault","target","value","Login","setUsername","password","setPassword","loginStatus","Home","App","interceptors","request","use","config","Authorization","error","Promise","reject","to","path","store","configureStore","reducer","sessionReducer","messagesReducer","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.dc47f1b0.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\nimport type { RootState, AppDispatch } from './store';\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { getMessages } from './messagesAPI';\n\nexport interface Msg{\n  username: string,\n  userId: number,\n  timestamp: number,\n  channelId: number,\n  text: string\n}\n\nexport interface MessagesState {\n  [x: string]: Msg[]\n}\n\nconst initialState: MessagesState = {};\n\nexport interface MsgRequest {\n  channelId: number,\n  timestamp: number,\n  amount: number\n}\n\nexport const getMessagesAsync = createAsyncThunk(\n  'messages/get',\n  async (msgRequest: MsgRequest): Promise<Msg[]> => {\n    const response = await getMessages(msgRequest.channelId, msgRequest.timestamp, msgRequest.amount);\n    return response.data;\n  }\n);\n\nexport const messagesSlice = createSlice({\n  name: 'messages',\n  initialState,\n  reducers: {\n    addMessage: (state, action) => {\n      if(state.hasOwnProperty(action.payload.channelId))\n        state[action.payload.channelId].push(action.payload.msg)\n      else\n      state[action.payload.channelId] = [action.payload.msg]\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(getMessagesAsync.fulfilled, (state, action) => {\n        if(action.payload.length > 0){\n          const channelId = action.payload[0].channelId.toString()\n\n          if(state.hasOwnProperty(channelId)){\n            state[channelId].concat(action.payload)\n            state[channelId] = state[channelId].sort((m1, m2) => m1.timestamp - m2.timestamp)\n          }else{\n            state[channelId] = action.payload\n          }\n        }\n      });\n  },\n});\n\nexport const { addMessage } = messagesSlice.actions;\n\nexport default messagesSlice.reducer;\n","import axios, { AxiosResponse } from \"axios\";\nimport { Msg } from \"./messagesSlice\";\n\nexport const getMessages = (channelId: number, timestamp: number, amount: number): Promise<AxiosResponse<Msg[]>> => {\n  return axios.get(`/channels/${channelId}/messages?timestamp=${timestamp}&number=${amount}`)\n}","import axios, { AxiosResponse } from \"axios\";\nimport { Server } from \"./sessionSlice\";\n\nexport interface LoginRequest {\n  username: string,\n  password: string\n}\n\nexport const login = (loginRequest: LoginRequest): Promise<AxiosResponse<{username: string, userId: number}>> => {\n  return axios.post('/auth', loginRequest)\n}\n\nexport const getChannels = (): Promise<AxiosResponse<Server[]>> => {\n  return axios.get('/users/channels')\n}","import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { getChannels, login, LoginRequest } from './sessionAPI';\n\nexport interface Channel {\n  role: string,\n  name: string,\n  channelId: number,\n  serverId: number\n}\n\nexport interface Server {\n  name: string,\n  serverId: number,\n  channels: Channel[]\n}\n\nexport interface User {\n  username: string,\n  id: number\n}\n\nexport interface Connection {\n  status: 'active' | 'connecting' | 'disconnected',\n  serverId: number,\n  currentChannelId: number\n}\n\nexport interface SessionState {\n  status: 'loading' | 'none' | 'active',\n  token: string | null,\n  user: User | null,\n  servers: Server[],\n  connection: Connection | null\n}\n\nconst initialState: SessionState = {\n  status: 'none',\n  token: null,\n  user: null,\n  servers: [],\n  connection: null\n};\n\nexport const loginAsync = createAsyncThunk(\n  'session/login',\n  async (loginRequest: LoginRequest): Promise<{username: string, userId: number, token: string} | null> => {\n    const response = await login(loginRequest);\n    return {...response.data, token: response.headers[\"authorization\"]}\n  }\n);\n\nexport const getChannelsAsync = createAsyncThunk(\n  'session/getChannels',\n  async (): Promise<Server[]> => {\n    const response = await getChannels();\n    return response.data;\n  }\n);\n\nexport const sessionSlice = createSlice({\n  name: 'session',\n  initialState,\n  reducers: {\n    logoutAction: (state) => {\n      state.user = initialState.user\n      state.token = initialState.token\n      state.status = initialState.status\n      state.servers = initialState.servers\n      state.connection = initialState.connection\n    }\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(loginAsync.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(loginAsync.fulfilled, (state, action) => {\n        if(action.payload != null){\n          state.status = 'active';\n          state.user = {\n            username: action.payload.username,\n            id: action.payload.userId\n          }\n          state.token = action.payload.token;\n        }\n      })\n      .addCase(getChannelsAsync.fulfilled, (state, action) => {\n        state.servers = action.payload\n      });\n  },\n});\n\nexport const { logoutAction } = sessionSlice.actions;\n\nexport default sessionSlice.reducer;\n","import React, { ChangeEvent, useEffect, useState } from 'react';\nimport { useHistory } from 'react-router';\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { addMessage, getMessagesAsync, Msg } from '../features/messages/messagesSlice';\nimport { getChannelsAsync } from '../features/session/sessionSlice';\nimport useWebSocket, { ReadyState } from 'react-use-websocket';\nimport './Chat.css';\n\nexport const Chat = () => {\n    const sessionStatus = useAppSelector(state => state.session.status)\n    const history = useHistory()\n    const dispatch = useAppDispatch()\n\n    const token = useAppSelector(state => state.session.token)\n\n    const [selectedServer, setSelectedServer] = useState(0)\n    const [selectedChannel, setSelectedChannel] = useState(0)\n\n    const [input, setInput] = useState('')\n\n    const servers = useAppSelector(state => state.session.servers)\n    const msgs = useAppSelector(state => state.messages)\n\n    const href = window.location.href\n    const socketUrl = `ws${href.substring(4, href.length-4)}connect`;\n    const {\n        sendMessage,\n        lastMessage,\n        readyState,\n    } = useWebSocket(socketUrl);\n\n    useEffect(() => {\n        if(servers.length == 0)\n            return;\n\n        const serverId = servers[selectedServer].serverId\n\n        sendMessage(JSON.stringify({\n            type: \"change\",\n            msg: {\n                serverId\n            }\n        }))\n    }, [selectedServer])\n\n    useEffect(() => {\n        if(servers.length > 0 && readyState == ReadyState.OPEN){\n            sendMessage(JSON.stringify({\n                token,\n                serverId: servers[selectedServer].serverId\n            }))\n        }\n    }, [servers, readyState])\n\n    useEffect(() => {\n        if(lastMessage != null){\n            const msg = JSON.parse(lastMessage?.data)\n            if(msg.hasOwnProperty('status')){\n                console.log('ready')\n            }else{\n                dispatch(addMessage({channelId: msg.channelId, msg}))\n            }\n        }\n    }, [lastMessage])\n\n    useEffect(() => {\n        dispatch(getChannelsAsync())\n    }, [])\n\n    useEffect(() => {\n        console.log('effect')\n        if(servers.length == 0)\n            return;\n\n        const channelId = servers[selectedServer].channels[selectedChannel].channelId\n        if(!msgs.hasOwnProperty(channelId) || msgs[channelId].length == 0){\n            dispatch(getMessagesAsync({channelId, timestamp: Date.now(), amount: 20}))\n        }\n    })\n\n    if(servers.length == 0)\n        return (<div>Loading</div>)\n\n    const selectedServerChannels = servers[selectedServer].channels\n\n    var messages: Msg[] = []\n    var id = servers[selectedServer].channels[selectedChannel].channelId\n    if(msgs.hasOwnProperty(id))\n        messages = msgs[id.toString()]\n    const selectedChannelMsgs = messages\n\n    const selectServer = (id: number) => () => {\n        const idx = servers.findIndex(server => server.serverId == id)\n        setSelectedServer(idx)\n        setSelectedChannel(0)\n    }\n\n    const selectChannel = (id: number) => () => {\n        const idx = selectedServerChannels.findIndex(channel => channel.channelId == id)\n        setSelectedChannel(idx)\n    }\n\n    const inputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        event.preventDefault()\n        setInput(event.target.value)\n    }\n\n    const send = () => {\n        const channelId = servers[selectedServer].channels[selectedChannel].channelId\n\n        sendMessage(JSON.stringify({\n            type: \"send\",\n            msg: {\n                timestamp: Date.now(),\n                text: input,\n                channelId\n            }\n        }))\n        setInput('')\n    }\n\n    const formatTimestamp = (timestamp: number) => {\n        var date = new Date(timestamp);\n        var hours = date.getHours();\n        var minutes = \"0\" + date.getMinutes();\n        var seconds = \"0\" + date.getSeconds();\n        var year = date.getFullYear();\n        var month = date.getMonth();\n        var day = date.getDay()\n        return day + '/' + month + '/' + year + ' ' + hours + ':' + minutes.substr(-2) + ':' + seconds.substr(-2);\n    }\n\n    if(sessionStatus != 'active')\n        history.push('/login')\n\n    const selectedServerId = servers[selectedServer].serverId\n    const selectedChannelId = servers[selectedServer].channels[selectedChannel].channelId\n\n    return (\n        <div>\n            <div className={\"serverPanel\"}>\n                {servers.map(server => \n                    <div key={server.serverId}>\n                        <p>{server.name}</p>\n                        <button onClick={selectServer(server.serverId)}>{(server.serverId == selectedServerId) ? \"\" : \"SELECT\"}</button>\n                    </div>\n                )}\n            </div>\n            <div className={\"channelsPanel\"}>\n                {selectedServerChannels.map(channel => \n                    <div key={channel.channelId}>\n                        <p>{channel.name}</p>\n                        <button onClick={selectChannel(channel.channelId)}>{(channel.channelId == selectedChannelId) ? \"\" : \"SELECT\"}</button>\n                    </div>\n                )}\n            </div>\n            <div className={\"chat\"}>\n                {selectedChannelMsgs.map(msg => \n                    <div key={msg.userId * msg.timestamp}>\n                        <p>[{formatTimestamp(msg.timestamp)}] {msg.username}: {msg.text}</p>\n                    </div>\n                )}\n                <form>\n                    <p>Message:</p>\n                    <input\n                    type='text'\n                    onChange={inputChange}\n                    />\n                </form>\n                <button onClick={send}>\n                    SEND\n                </button>\n            </div>\n        </div>\n    )\n}","import React, { useState } from 'react';\nimport { useSelector } from 'react-redux';\nimport { useHistory } from 'react-router';\nimport { useAppDispatch, useAppSelector } from '../app/hooks';\nimport { loginAsync } from '../features/session/sessionSlice';\n\nexport const Login = () => {\n    const [username, setUsername] = useState('')\n    const [password, setPassword] = useState('')\n    const dispatch = useAppDispatch()\n    const history = useHistory()\n\n    const loginStatus = useAppSelector(state => state.session.status)\n\n    if(loginStatus == 'active')\n        history.push('/chat')\n\n    const passwordChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        event.preventDefault()\n        setPassword(event.target.value)\n    }\n\n    const usernameChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n        event.preventDefault()\n        setUsername(event.target.value)\n    }\n\n    const login = () => {\n        dispatch(loginAsync({username, password}))\n    }\n\n    return (\n        <div>\n            Status: {loginStatus}\n            <form>\n            <p>Username:</p>\n            <input\n            type='text'\n            onChange={usernameChange}\n            />\n            <p>Password:</p>\n            <input\n            type='password'\n            onChange={passwordChange}\n            />\n            </form>\n            <button onClick={login}>\n                Login\n            </button>\n        </div>\n    );\n}","import React from 'react';\n\nexport const Home = () => (\n    <div>\n        Home\n    </div>\n)","import React from 'react';\nimport './App.css';\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\";\nimport { useAppDispatch, useAppSelector } from './app/hooks';\nimport { Chat } from './components/Chat';\nimport { Login } from './components/Login';\nimport { Home } from './components/Home';\nimport { logoutAction } from './features/session/sessionSlice';\nimport axios from 'axios';\n\nfunction App() {\n  const username = useAppSelector(state => state.session.user?.username)\n  const status = useAppSelector(state => state.session.status)\n  const token = useAppSelector(state => state.session.token)\n\n  const dispatch = useAppDispatch()\n\n  if(token != null){\n    axios.interceptors.request.use(function (config) {\n      config.headers.Authorization = token;\n      return config;\n    }, function (error) {\n      return Promise.reject(error);\n    });\n  }\n\n  const logout = () => {\n    dispatch(logoutAction())\n  }\n\n  return (\n    <Router>\n      <div>\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/\">Home</Link>\n            </li>\n            <li>\n              <Link to=\"/chat\">Chat</Link>\n            </li>\n            {status == 'none' &&\n              <li>\n                <Link to=\"/login\">Login</Link>\n              </li>\n            }\n            {status == 'active' &&\n              <li>\n                Witaj, {username}\n              </li>\n            }\n            {status == 'active' &&\n              <li>\n                <button onClick={logout}>Logout</button>\n              </li>\n            }\n          </ul>\n        </nav>\n\n        <Switch>\n          <Route path=\"/chat\">\n            <Chat />\n          </Route>\n          <Route path=\"/login\">\n            <Login />\n          </Route>\n          <Route path=\"/\">\n            <Home />\n          </Route>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","import { configureStore, ThunkAction, Action } from '@reduxjs/toolkit';\nimport messagesReducer from '../features/messages/messagesSlice';\nimport sessionReducer from '../features/session/sessionSlice';\n\nexport const store = configureStore({\n  reducer: {\n    session: sessionReducer,\n    messages: messagesReducer\n  },\n});\n\nexport type AppDispatch = typeof store.dispatch;\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  Action<string>\n>;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { store } from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}